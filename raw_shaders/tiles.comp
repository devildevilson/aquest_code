#version 450

#extension GL_GOOGLE_include_directive : enable
#include "../render/shared_structures.h"
#include "../utils/shared_mathematical_constant.h"

layout(constant_id = 0) const float triangle_size = 23.8457f;
//layout(constant_id = 0) const float triangle_size = 10.0f;

layout(set = 0, binding = 0) uniform Camera {
  mat4 viewproj;
  mat4 view;
  vec4 pos;
  vec4 dir;
  uvec4 dim;
} camera;

layout(std140, set = 1, binding = 0) readonly buffer tiles_buffer {
  light_map_tile_t tiles[];
};

layout(std140, set = 1, binding = 2) readonly buffer tile_points_buffer {
  vec4 tile_points[];
};

layout(std140, set = 1, binding = 3) readonly buffer triangles_buffer {
  packed_fast_triangle_t triangles[];
};

layout(std430, set = 1, binding = 4) readonly buffer triangles_tile_indices_buffer {
  uvec4 triangles_tile_indices[];
};

layout(std140, set = 2, binding = 0) buffer tile_indirect_buffer {
  uvec4 tiles_indirect;
  uvec4 tiles_data;
  uvec4 borders_indirect;
  uvec4 borders_data;
  uvec4 walls_indirect;
  uvec4 walls_data;
  // сюда можно засунуть фрустум
  frustum_t frustum;
};

layout(std430, set = 2, binding = 1) buffer tiles_indices_buffer {
  instance_data_t tiles_indices[];
};

layout(std430, set = 2, binding = 2) buffer borders_indices_buffer {
  instance_data_t borders_indices[];
};

layout(std430, set = 2, binding = 3) buffer walls_indices_buffer {
  instance_data_t walls_indices[];
};

#define FAR_PLANE 256.0f
#define WORK_GROUP 256

float distance2(const vec4 a, const vec4 b);
vec4 get_triangle_dir(const vec4 a, const vec4 b, const vec4 c);
bool triangle_frustum_test(const vec4 a, const vec4 b, const vec4 c, const frustum_t frustum);
uint get_accel_triangle_tile_index(const uint index);

//shared uint pentagon_count;
//shared uint hexagon_count;
layout(local_size_x = WORK_GROUP, local_size_y = 1, local_size_z = 1) in;

void main() {
  // pentagon_count = 0;
  // hexagon_count = 0;
  //
  // barrier();

  const uint triangle_count = tiles_data[1];
  const uint max_indices_count = tiles_data[2];
  const uint triangle_index = gl_GlobalInvocationID.x;
  if (triangle_index >= triangle_count) return;

  const uint borders_indices_count = borders_data[1];
  const uint walls_indices_count = walls_data[1];

  //const light_map_tile_t tile = tiles[tile_index];
  const packed_fast_triangle_t triangle = triangles[triangle_index];

  const vec4 a = tile_points[triangle.points.x];
  const vec4 b = tile_points[triangle.points.y];
  const vec4 c = tile_points[triangle.points.z];

  const vec4 dir = get_triangle_dir(a, b, c);

  //const uint center_index = tile.tile_instances.x;

  //const vec4 point = tile_points[center_index];

  const vec4 camera_dir = camera.dir;
  const vec4 camera_pos = camera.pos;

  // должны быть в разные стороны
  // *vec4(1.0f, 1.0f, 1.0f, 0.0f)
  if (dot(dir, camera_dir) >= 0.0f) return;
  //if (dot(point, camera_dir) >= 0.0f) return;

  //const float approx_dist = (FAR_PLANE + 4.0f) * (FAR_PLANE + 4.0f);
  //if (distance2(camera_pos, point) > approx_dist) return;

  if (!triangle_frustum_test(a, b, c, frustum)) return;

  // triangle.data[1] - количество тайлов всего, triangle.data[2] - есть ли среди них пентагон
  // пентагон должен быть всегда последним
  const uint new_tiles_count = triangle.data[1] - triangle.data[2];
  const uint new_indices_count = (new_tiles_count * 7) + (triangle.data[2] * 6); // 6 индексов + 1 рестарт
  const uint new_indices_offset = atomicAdd(tiles_indirect.x, new_indices_count);

  if (new_indices_offset + new_indices_count >= max_indices_count) return;

  for (uint i = 0; i < new_tiles_count; ++i) {
    const uint tile_index = get_accel_triangle_tile_index(triangle.data[0] + i);
    const uint pack_tile = tile_index * PACKED_TILE_INDEX_COEF;
    const uint offset = new_indices_offset + i*(PACKED_TILE_INDEX_COEF+1);
    for (uint j = 0; j < PACKED_TILE_INDEX_COEF; ++j) {
      const uint index = offset + j;
      const uint vec_index = index / 4;
      const uint slot_index = index % 4;
      tiles_indices[vec_index].index[slot_index] = pack_tile + j;
    }

    const uint index = offset + PACKED_TILE_INDEX_COEF;
    const uint vec_index = index / 4;
    const uint slot_index = index % 4;
    tiles_indices[vec_index].index[slot_index] = GPU_UINT_MAX;
  }

  if (bool(triangle.data[2])) {
    const uint tile_index = get_accel_triangle_tile_index(triangle.data[0] + triangle.data[1] - 1);
    const uint pack_tile = tile_index * PACKED_TILE_INDEX_COEF;
    const uint offset = new_indices_offset + new_tiles_count * (PACKED_TILE_INDEX_COEF+1);
    for (uint j = 0; j < 5; ++j) {
      const uint index = offset + j;
      const uint vec_index = index / 4;
      const uint slot_index = index % 4;
      tiles_indices[vec_index].index[slot_index] = pack_tile + j;
    }

    const uint index = offset + 5;
    const uint vec_index = index / 4;
    const uint slot_index = index % 4;
    tiles_indices[vec_index].index[slot_index] = GPU_UINT_MAX;
  }

  // теперь мы можем проверить и добавить границы и соединения
  if (walls_indices_count == 0) return;
  for (uint i = 0; i < triangle.data[1]; ++i) {
    const uint tile_index = get_accel_triangle_tile_index(triangle.data[0] + i);
    const uint walls_data = tiles[tile_index].packed_data4[1]; // блин у меня весь буффер используется только для двух переменных, наверное стоит вытащить их в другой буфер
    if (walls_data == GPU_UINT_MAX) continue;

    // было бы неплохо убрать те соединения, которые мы не видим
    // как это сделать? мне для этого нужен буфер со стенами
    const uint size = (walls_data >> 28) & connections_size_mask;
    const uint offset = walls_data & connections_offset_mask;
    const uint index_offset = atomicAdd(walls_indirect.x, size*(PACKED_INDEX_COEF+1));

    for (uint j = 0; j < size; ++j) { // каждое соединение добавляем отдельно
      const uint index = index_offset + j*(PACKED_INDEX_COEF+1);
      const uint wall_index = offset + j;
      const uint packed_index = wall_index * PACKED_INDEX_COEF;
      for (uint k = 0; k < PACKED_INDEX_COEF; ++k) {
        const uint final_index = index + k;
        const uint vec_index = final_index / 4;
        const uint slot_index = final_index % 4;
        walls_indices[vec_index].index[slot_index] = packed_index + k;
      }

      const uint final_index = index + PACKED_INDEX_COEF;
      const uint vec_index = final_index / 4;
      const uint slot_index = final_index % 4;
      walls_indices[vec_index].index[slot_index] = GPU_UINT_MAX;
    }
  }

  if (borders_indices_count == 0) return;
  for (uint i = 0; i < triangle.data[1]; ++i) {
    const uint tile_index = get_accel_triangle_tile_index(triangle.data[0] + i);
    const uint borders_data = tiles[tile_index].packed_data4[0];
    if (borders_data == GPU_UINT_MAX) continue;

    const uint size = (borders_data >> 28) & border_size_mask;
    const uint offset = borders_data & border_offset_mask;
    const uint index_offset = atomicAdd(borders_indirect.x, size*(PACKED_INDEX_COEF+1));

    for (uint j = 0; j < size; ++j) { // каждую границу добавляем отдельно
      const uint index = index_offset + j*(PACKED_INDEX_COEF+1);
      const uint border_index = offset + j;
      const uint packed_index = border_index * PACKED_INDEX_COEF;
      for (uint k = 0; k < PACKED_INDEX_COEF; ++k) {
        const uint final_index = index + k;
        const uint vec_index = final_index / 4;
        const uint slot_index = final_index % 4;
        borders_indices[vec_index].index[slot_index] = packed_index + k;
      }

      const uint final_index = index + PACKED_INDEX_COEF;
      const uint vec_index = final_index / 4;
      const uint slot_index = final_index % 4;
      borders_indices[vec_index].index[slot_index] = GPU_UINT_MAX;
    }
  }

  // мне необходимо два миллиона тайлов проверить на видимость
  // крайне быстрый способ заключается в том что я могу легко продотать
  // все тайлы и убрать те из них что смотрят в другую сторону
  // вообще справедливо то что множество гексов останутся от кадра к кадру

  // на 3-ем и 4-ом уровнях иерархической структуры лежат 1280 и 5120 треугольников соответственно
  // на самом деле достаточно проверить лишь это количество треугольников
  // в этом случае должно быть гораздо быстрее

  // 5120 треугольников выдают по 100 тайлов каждый примерно (7 уровень детализации)
  // tile_indices - это инстансный буфер, мы его можем расширить,
  // например нам возможно потребуется посчитать uv координаты
  // вообще uv координаты зависят не от тайла, а от точки,
  // и для всех точек uv развертку можно посчитать заранее
}

float distance2(const vec4 a, const vec4 b) {
  const vec4 dir = b-a;
  return dot(dir, dir);
}

vec4 get_triangle_dir(const vec4 a, const vec4 b, const vec4 c) {
  const vec4 ab = b-a;
  const vec4 ac = c-a;
  return vec4(cross(vec3(ab), vec3(ac)), 0.0f);
}

#define OUTSIDE 0
#define INSIDE 1
#define INTERSECT 2

bool triangle_frustum_test(const vec4 a, const vec4 b, const vec4 c, const frustum_t frustum) {
  const vec4 center = (a + b + c) / 3.0f;
  const vec4 extents = vec4(triangle_size, triangle_size, triangle_size, 0.0f);

  uint result = INSIDE;
  for (uint i = 0; i < 6; ++i) {
    // const float dist = dot(center.xyz, frustum.planes[i].xyz) + frustum.planes[i].w + triangle_size;
    // if (dist < 0.0f) return false;

    const vec4 plane = vec4(frustum.planes[i][0], frustum.planes[i][1], frustum.planes[i][2], 0.0f); //frustum.planes[i] * simd::vec4(1.0f, 1.0f, 1.0f, 0.0f);
    const float p3 = frustum.planes[i][3];

    const float d = dot(center,      plane);

    const float r = dot(extents, abs(plane));

    const float d_p_r = d + r;
    const float d_m_r = d - r;

    //frustumPlane.w
    if (d_p_r < -p3) {
      result = OUTSIDE;
      break;
    } else if (d_m_r < -p3) result = INTERSECT;
  }

  return result != OUTSIDE;
}

uint get_accel_triangle_tile_index(const uint index) {
  const uint vec4_index = index / 4;
  const uint vec4_offset = index % 4;
  return triangles_tile_indices[vec4_index][vec4_offset];
}
