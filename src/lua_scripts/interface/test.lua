-- интерфейс, как он должен работать? я изначально планировал сделать слои в с++
-- то есть пихаем функции луа по слоям, и вызываем их, когда нам окно стало не нужно
-- закрываем слой, проблема в том что мне приходится самому прикидывать что мне нужно, а что нет
-- когда закрыть интерфейс, когда вызвать меню, из с++ не очень понятно когда что нужно сделать
-- у меня в любом случае в игре будет по крайней мере одна функция интерфейса,
-- которая в любом случае будет запускаться каждый кадр, почему бы не сделать
-- тогда весь интерфейс в этой функции? то есть всю нужную информацию для игрока будем передавать
-- в эту функцию, а в ней уже рисовать какие нибудь окна, например: полезные кнопки (персонаж, дипломатия и проч),
-- валюта (деньги, престиж и проч), в какой то момент нам потребуется открывать окна,
-- например окно персонажа, и закрывать их же, все это вполне можно сделать в единой функции
-- тяжелый ли луа? мне нетолько нужно тычить по кнопкам интерфейса, но и получать информацию
-- от выделения мышкой игровых объектов, проще расшарить информацию о выделении в луа и тут выбрать
-- что полезно, а что нет, остается еще вопрос что нужно сделать с парочкой команд
-- которые оттдавать только мышкой, например передвижение войск, их видимо нужно будет делать
-- через c++, другое дело что меня напрягает что так функциия может быть довольно тяжелой
-- с другой стороны, на что еще у меня тратится время кадра?, сделать 30 фпс - это решит наверное
-- 90% проблем с производительностью, что со строками для эвентов?
-- в эвентах нету простых строк с понятными источниками данных, там мы должны сначала обойти ряд условий
-- и только потом мы получим объект у которого нужно взять какие то данные, то есть когда к нам придет
-- эвент нам нужно будет еще его "скомпилировать" видимо мы должны получить какую то функцию
-- для отрисовки интерфейса эвента или таблицу с данными (строки или тоже функции)
-- клик мыши по выделенному объекту должен приводить к появлению окна объекта
-- короче клики мыши нужно обрабатывать, мож инпут тоже частично в луа выбросить? напрягает прост
-- производительность, но я еще не замерял, пока что просто домыслы

-- я тут подумал, наверное лучше сделать таблицы типа localization или utils
-- не глобальными, а по require, так нагляднее + не захламляется глобал + я могу из скрипта контролировать
-- что мне нужно, а что нет, но тут сложность с основными типами возникает, их нужно все же в глобале где то держать,
-- короче нужно разделить типы и функции (+ константы)

-- в moonnuklear есть много вещей которые я бы не хотел вытаскивать наружу, нужно будет еще
-- поработать над ним, скрыв "плохой" функционал
local nk = require("moonnuklear") -- это зарегестрированный Си модуль
local fmt = require("fmt")        -- это зарегестрированный Си модуль
local queue = require("apates_quest.scripts.queue")
-- lua модули будем грузить через точку

local escape = input.get_event("escape")

local int_table = {}

-- игра у меня пошаговая, а значит будет минимум два состояния игры: ход игрока и ожидание между ходами
-- как об этом узнать из луа? у нас в любом случае должен быть некий игровой контекст, откуда мы например
-- получим персонажа игрока, по идее рядом должен находиться способ узнать состояние игры
local function start_turn(nk_ctx, game_ctx, timer)
  local char = game_ctx.character
  --game_ctx.old_state
  local player_turn = game_ctx.current_state
  -- мне пригодится для анимации знать когда именно произойдет переход
  -- от одного состояния в другое
  -- скорее всего будет удобно сделать все в одной функции
end

local function check_state(state, check)
  return (state & check) ~= 0
end

local function keys_input()
  input.frame_events(function(id, state)
    local f = input_table[id.name()]
    if f ~= nil and check_state(state, input.press | input.click) then f() end
  end)
end

local function interface(nk_ctx, game_ctx, timer, local_table)
  -- функцию еще наверное нужно будет как то подготовить
  -- в локализации будет храниться видимо не только строки
  -- но и массивы и числа, но не другое
  -- форматирование строки будет происходить силами другой библиотеки
  -- плюрялизация будет наверное прикручена сверху
  local str = localization.get("month.jan") -- будем искать сначала в текущей локали, а затем в фаллбек локали

  -- loading_data - тут у нас будут данные из загрузок
  -- либо будет приходить nil если загрузки нет
  -- как передавать данные например в генератор?
  -- по идее нам нужно вызвать функцию, что то вроде: advance_generator(table)
  -- но при этом обязательно нужно почистить память и эту функцию нужно будет удалить
  -- как это все аккуратно сделать?
  -- ко всему прочему было бы неплохо сделать "блокировку" инпута во время игрового главного меню
  -- хотя это можно сделать через интерфейс
  -- мне останется контролировать входную функцию, откуда ее брать?
  -- она должна быть из конфига отдельным скриптом (?)
  -- и моды вполне могут использовать свою функцию интерфейса, как мне дать возможность
  -- запускать ее например при старте? значит мне нужно свободно перезагружать интерфейс
  -- (не в любом месте понятное дело) возможно нужно сохранять какие то данные между этим
  -- нужно все же наверное таскать с собой local_table, в которой будут например таблицы
  -- serialize_data и loading_data, первая будет сохраняться при сохранениях и перезагрузках
  -- и должна быть определенного формата, а во вторую иногда будут приходить данные от загрузок

  if game_ctx.state == game.state.main_menu then
    keys_input()
  elseif game_ctx.state == game.state.world_map then
    keys_input()
    mouse_input(timer.current_time)
  end
end

return interface
