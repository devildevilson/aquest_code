local nk = require("moonnuklear")

-- в цк3 окно с решениями было разделено на две секции major decisions и decisions
-- в этих секциях присутствовали только списки решений,
-- список представляет из себя последовательность прямоугольных секций с рамкой + названием решения + картинкой
-- решение сразу помечается как доступное с помощью рендера картинки (если недоступно то рендерится крестик) 
-- у рамки есть какая то текстура, картинка с явным эффектом градиента
-- 2 вопроса: как сделать рендер части картинки (или рендер прямоугольной картинки?)? и как сделать градиент для интерфейса?
-- в первом случае должен сработать стандартный наклировский способ рисовать часть картинки
-- во втором случае что? я бы хотел иметь возможность составлять слои, как для геральдики, но для общего рендера
-- как это сделать? ну собственно можно задать слои в таблице похожим образом как геральдику

-- возможно нужно "скомпилировать" эти слои? да думаю не лишено смысла, как компилировать? 
-- нужно для начала дождаться когда будут загружены картинки
local img_style = {
  {
    stencil = "h_gradient",
    colors = {},
    coords = { 0.0, 0.0, 1.0, 1.0 }, -- image location
    tex_coords = { 0.0, 0.0, 1.0, 1.0 }, -- image scale
    discard_layer = false,
    continue_layer = false
  },
  {
    -- image != stencil, colors игнорируются для image, но можно задать только либо stencil либо image 
    -- хотя почему только? я могу указать и то и то, для того чтобы задать интересный эффект
    -- тут проблема другая - стенсилы могут содержать информацию до 4 цветов, а у меня изображение одно
    -- поэтому наверное лучше пихнуть все же изображение в другой слот
    -- у стенсила есть альфа канал, по которому мы как раз и рисуем следущие слои, тут подойдет изображение
    image = "",
    coords = {0.0, 0.0, 1.0, 1.0},
    tex_coords = {0.0, 0.0, 1.0, 1.0},
    discard_layer = false,
    continue_layer = false
  }
}

-- вот еще что я вспомнил, градиент может быть смещен, это может быть сделано тремя путями:
-- 1) добавить еще одну переменную которую мы добавим к альфаканалу (сколько еще переменных нужно?)
-- 2) на самом деле рисовать 2 картинки, первая картинка - это 75% оригинала + еще 25% рядом (работает ли с моим способом? по идее можно указать текстурные координаты)
-- 3) сделать несколько градиентов: полный (от 0 до 1 на всем протяжении), 75% ([0,1] на 75% картинки), 50% и проч (это проще всего)

-- я еще хочу сделать откат с помощью градиента, как это сделать? это по идее текстурка + число, число отсекает часть альфа канала
-- на оставшейся части альфаканал константный + цвет

local compiled_styled_image = nil
local shield_img = nil

local function decision_panel(ctx, character, window_bounds)
  local available_decisions = core.get_potential_decisions(character)
  local decisions_count = #available_decisions
  for i = 1, decisions_count do
    local d = available_decisions[i]
    if d.major then 
      -- рисуем сначала мажорные решения

    end
  end

  if compiled_styled_image == nil then
    -- тут наверное нужно вернуть таблицу с перечислением слоев
    compiled_styled_image = interface.compile_layers(img_style)
    interface.alpha_stencil(stencil, 0.5, utils.make_color(0.3, 0.3, 0.3, 0.3)) -- тут в общем то все просто, но видимо придется завести еще один буфер
  end

  if shield_img == nil then
    shield_img = interface.get_image("apates_quest/shields.1")
  end

  if nk.window_begin(ctx, "character_decision_panel", window_bounds, nk.WINDOW_NO_SCROLLBAR) then
    interface.layered_image(compiled_styled_image, shield_img)
  end
end

return decision_panel